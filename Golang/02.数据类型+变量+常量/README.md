# 具有相同声明的未命名类型被视作同一类型---P35

# 数据类型

#### 基本数据类型

* 数值型

  * 整数型

    * int8，int16，int32，int64
    * uint8，uint16，int32，int64
    * \--------------------------------------------------------------------------

    * byte：uint8的别名
    * rune：int32的别名
    * int：64位操作系统则int64，32位操作系统则int32
    * uint：64位操作系统则uint64，32位操作系统则uint32

  * 浮点型

    * float32，float64

  * 复数型

    * complex64，complex128

* 布尔型

  * bool：占用1个字节，只能接受true和false

* 字符串

  * string

    

#### 复杂数据类型

* 数组 - 值类型
* 结构体 - 值类型
* 指针 - 引用类型
* 管道 - 引用类型 
* 函数 - 引用类型 
* 接口 - 引用类型 
* 切片 - 引用类型 
* 映射 - 引用类型 

#### 给类型起别名

```go
type myInt int // 此时 myInt 可以作为 int 使用
```

* 虽然说是起别名，但是 编译器认为 myInt和int不是同一种类型，它们仅仅是底层数据结构相同

* 别名类型无需转换，可以直接赋值


# 变量

#### 变量创建的方法

```go
// 方式1：指定变量类型
var i int      // 声明变量         // 可以声明的同时初始化
i = 10         // 为变量赋值       // 等价于 var i int = 10
fmt.Println(i) // 使用变量

// 方式2：使用类型推导 —— 必须显式初始化
var i          // 声明变量         // 可以声明的同时初始化
i = 10         // 为变量赋值       // 等价于 var i = 10
fmt.Println(i) // 使用变量

// 方式3：使用简洁语法 —— 不可以用于函数外的变量声明，只能用于局部变量
i := 10        // 声明变量并由类型推导初始化
fmt.println(i) // 使用变量

// 方式4：同时创建多个全局变量 —— 既能用于函数外的变量声明，又能用户函数内声明
var (                                      
    n1 = 100
    name = "gothicrush"
    n3 = 200
)
```

#### 引用类型变量相关

* 对于引用类型变量，声明后还不能使用，在为它分配内存空间后才能使用

* 分配内存空间有两个函数

  * new(type)

    * 只接收一个参数，该参数为一个类型
    * 函数返回只想该类型内存地址的指针，该内存地址的值为类型零值

  * make(type, len, prelen)

    * 只适用于 slice, map, channel

    * prelen为预留长度，切片的预留长度需要重新切片后才能使用

      ```go
      a := make([]int, 10, 20)
      b := a[:cap(a)]
      ```

#### 变量作用域

* 全局作用域：函数外定义的变量，可以在包中或整个程序(大写开头)中使用
* 局部作用域：函数内定义的变量，只能在函数内使用
* 当函数内部的局部变量和全局变量重名时，编译器采用就近原则，即局部变量覆盖全局变量

#### 变量的注意事项

* 变量声明后，系统自动为它初始化为默认值

  在go 中，数据类型都有一个默认值，当程序员没有赋值时，编译器默认给它赋一个默认值

  ```go
  整数型 0
  浮点型 0.0
  复数型 0+0j
  布尔型 false
  字符型 ""
  复合类型 nil
  ```

* 支持一行语句中声明多个变量

  ```go
  var n1 int, n2 string, n3 int              //不推荐使用
  
  var n1, name, n3 = 100, "gothicrush", 200  //不推荐使用
  
  n1, name, n3 := 100, "gothicrush", 200     //不推荐使用
  
  // 当进行多变量赋值时，会先计算出所有的右值，然后再完成赋值操作
  ```

* 查看变量的类型和占用字节大小

  ```go
  fmt.Printf("%T", n1)
  fmt.Printf("%d", unsafe.Sizeof(n1))
  ```

* golang的整型默认为int类型

  * 64位操作系统则int64
  * 32位操作系统则int32

* 浮点数都是有符号的，golang的浮点型默认为float64

* 浮点数表示方式

  ```go
  var n1 float64 = 0.12
  var n2 float64 = .12
  var n3 float64 = 5.123e2
  ```

* golang的字符使用utf-8编码，避免乱码的问题

  * 字母：1个字节
  * 汉字：3个字节

* golang中没有专门的字符类型

  * 对于ascii编码，用byte存储
  * 对于utf-8编码，用rune存储

* 字符常量用单引号括起来，字符类型可以参与运算，因为它本质上是整型

* 在Go中字符串是不可变的，字符串有两种形式

  ```go
  // 1. 双引号，会识别转义字符
  // 2. 反引号，原生输出，原来是什么，就是什么；反引号可以多行
  ```

* 字符串拼接

  ```go
  var str = "hello" + " world" +  //如果是多行，需要将 + 放在上面
            "多行"
  ```

### Go类型转换

* 基本概念

```go
go中不存在自动(隐式)转换，只有显式转换，就算是低精度->高精度都要显式转换
语法：T(value)
var i int = 42
var b float64 = float64(i)
```

* 注意事项
  * 转换后返回一个新的，被转换的值本身没有变化
  * 如果转换过程中发生溢出（比如int64->int8），则不会报错，只是会按溢出处理
  * 不能将低精度向高精度强转，可以将高精度往低精度转

### 基本数据类型与string转换

```go
使用 strconv 包
```

* 基本数据类型转为string

  ```go
  strconv.Itoa(i)
  ```

* string转为基本数据类型

  ```go
  b, err := strconv.ParseBool(str)
  i, err := strconv.ParseInt(str, 10, 64) // 10进制，int64
  f, err := strconv.ParseFloat(str, 64)   // float64
  
  如果转换失败，则返回为默认值，还有err
  ```
  
  
  
# 常量

* 常量用 const 修饰（const替代var）

* 常量在定义时必须初始化，一旦初始化就不能更改

* 量必须是编译期可以确定的字符，字符串，数字或布尔值

* const只能修饰 bool类型，数值类型，string类型

* 常量中如果想要使用函数，则只能使用内置函数

* 常量不能用 := 创建，因为需要 const

* 常量简洁写法

  ``` go
  const (
      a = 1
      b = 2
  )
  ```

* 常量借助iota实现枚举

  ```go
  const (      // iota是一个内置的变量，用于存储 const 组中常量的个数
      a = iota // 0，iota从零开始，组内每定义一个常量，自增1
      b        // 1
      c        // 2
  )
  // 每遇到一个const，iota自动清零
  const (
      d = iota // 0
      e, f = iota, iota // 1, 1
      g = iota // 2
  )
  ```

* Go没有常量必须大写字母开头的规范，因为常量仍然有大小写字母开头控制访问范围的机制

* 定义常量后不使用，不会报错

* 赋值时，右值不能超出取值范围，否则报错

* 数字常量不会分配存储空间，故无法获取其地址
 
* 在常量组中，如果不指定类型和初始化值，则与上一行非空常量右值相同
  ```go
    const (
        x uint16 = 120
	    y                // uint16 = 120
	    s = "abc"        
	    z                // z = "abc"
    )
  ```
  
* itoa 重点学习 [Go学习笔记]
